" All system-wide defaults are set in $VIMRUNTIME/archlinux.vim (usually just
" /usr/share/vim/vimfiles/archlinux.vim) and sourced by the call to :runtime
" you can find below.  If you wish to change any of those settings, you should
" do it in this file (/etc/vimrc), since archlinux.vim will be overwritten
" everytime an upgrade of the vim packages is performed.  It is recommended to
" make changes after sourcing archlinux.vim since it alters the value of the
" 'compatible' option.

" This line should not be removed as it ensures that various options are
" properly set to work with the Vim-related packages.
runtime! archlinux.vim
" runtime! vimrc_example.vim

" If you prefer the old-style vim functionalty, add 'runtime! vimrc_example.vim'
" Or better yet, read /usr/share/vim/vim72/vimrc_example.vim or the vim manual
" and configure vim to your own liking!

syntax on

set nocompatible
set autoread
set title
set t_Co=256 "Active le mode 256 couleurs

" If using a dark background within the editing area and syntax highlighting
" turn on this option as well
"set background=dark

" Uncomment the following to have Vim jump to the last position when
" reopening a file
if has("autocmd")
	au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

" Uncomment the following to have Vim load indentation rules and plugins
" according to the detected filetype.
if has("autocmd")
	filetype plugin indent on
endif


set backspace=indent,eol,start

"let loaded_minibufexplorer = 0

"let g:miniBufExplMapWindowNavVim = 1 
"let g:miniBufExplMapWindowNavArrows = 1 
"let g:miniBufExplMapCTabSwitchBufs = 1 
"let g:miniBufExplModSelTarget = 1 

" The following are commented out as they cause vim to behave a lot
" differently from regular Vi. They are highly recommended though.
"set showcmd		" Show (partial) command in status line.
set showmatch		" Show matching brackets.
"set ignorecase		" Do case insensitive matching
set smartcase		" Do smart case matching
set incsearch		" Incremental search
"set autowrite		" Automatically save before commands like :next and :make
"set hidden         " Hide buffers when they are abandoned
set mouse=a		" Enable mouse usage (all modes)
set number
set shortmess=at
set wildignore=*.o,*.obj,*.bak,*.exe

set nostartofline
set sessionoptions+=buffers,curdir

" Permet de toujours concerver les proportions pour les splits
set noequalalways

" Indent
set autoindent
set smartindent
set softtabstop=4
set tabstop=4
set shiftwidth=4
set noexpandtab
"En mode visuel conserve le bloc indenté
vnoremap < <gv
vnoremap > >gv
" Use TAB
nnoremap <TAB> >>
vmap <TAB> >
nnoremap <S-TAB> <<
vmap <S-TAB> <

" Options pour le mode diff
set diffopt=filler,iwhite,vertical

" Mode turbo
set ttyfast
set showcmd
"set noswapfile

" Souligne les resultats
set hlsearch
"Recherche intelligente
set smartcase
highlight Search ctermfg=Black ctermbg=yellow cterm=NONE

" Ligne suivante/précédente ssi flèches droite/gauche en bout de ligne
set whichwrap=<,>,[,]

set laststatus=2
set statusline= " clear
set statusline+=%-3.3n\ " nombre buffer
set statusline+=%f\ " nom fichier
set statusline+=%h%m%r%w " flags
set statusline+=[%{strlen(&ft)?&ft:'none'}, " type fichier
set statusline+=%{strlen(&fenc)?&fenc:&enc}, " encodage
set statusline+=%{&fileformat}] " format fichier
set statusline+=%#warningmsg# " Syntastic
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
set statusline+=%= " alignement droite
set statusline+=%-14.(%l,%c%V%)\ %<%P " offset

set cursorline
hi CursorLine cterm=NONE ctermbg=black ctermfg=NONE guibg=NONE guifg=NONE
hi CursorLineNr cterm=NONE ctermbg=NONE ctermfg=yellow guibg=NONE guifg=NONE
"hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white

"colorscheme camo

hi Visual ctermfg=black ctermbg=Red

" Avoid screen problem for (Meta) Left and (Meta) right
"if $TERM =~ 'screen' 
"	nmap [1;5D B
"	nmap [1;5C W
"	inoremap <Esc>[1;5C <C-O>W
"	inoremap <Esc>[1;5D <C-O>B
"endif 

" Map ctrl+s for saving
noremap <C-s> :update<CR>
vnoremap <C-s> <C-C>:update<CR>
inoremap <C-s> <C-O>:update<CR>

" Map ctrl+q to quit all files
noremap <C-q> :qa<CR>
vnoremap <C-q> <C-C>:qa<CR>
inoremap <C-q> <C-O>:qa<CR>

" Shortcut to save/restore sessions
nnoremap <F5> :mksession! ~/.vim/sessions/
nnoremap <F6> :so ~/.vim/sessions/

set pastetoggle=<F2>

" Copy/cut/past in visual mode using clipboard
vnoremap <C-c> "+y
vnoremap <C-x> "+d
vnoremap <C-v> "+p

" number and foldcolumn on/off
noremap	<F3> :set nonumber <bar> set foldcolumn=0 <CR>
noremap	<F4> :set number <bar> set foldcolumn=1 <CR>

" ctrl+page-up or ctrl+page-down
noremap [6^ :next<CR>
noremap [5^ :prev<CR>

" Source a global configuration file if available
if filereadable("/etc/vim/vimrc.local")
	source /etc/vim/vimrc.local
endif

" Increase mapping reactivity (The time in milliseconds that is waited for a key code or mapped key sequence to complete)
set timeout timeoutlen=3000 ttimeoutlen=100

" Syntastic
let g:syntastic_enable_signs=1
let g:syntastic_auto_loc_list=1

let g:SuperTabDefaultCompletionType = "context"

" Folding {{{
if has ('folding')
	set foldenable
	set foldmethod=marker
	set foldmarker={{{,}}}
	set foldcolumn=1
endif

" Sauve et charge automatiquement les folds
autocmd BufWinLeave * if expand("%") != "" | mkview | endif
autocmd BufWinEnter * if expand("%") != "" | loadview | endif

" Fold Toogle
inoremap <F1> <C-O>za
nnoremap <F1> za
onoremap <F1> <C-C>za
vnoremap <F1> zf


hi FoldColumn cterm=NONE ctermbg=black ctermfg=green guibg=NONE guifg=NONE
hi Folded cterm=NONE ctermbg=black ctermfg=green guibg=NONE guifg=NONE
" }}}

" Spell
if has("spell")
	if !filewritable($HOME."/.vim/spell")
		call mkdir($HOME."/.vim/spell", "p")
	endif
	set spellsuggest=10 "10 suggestions
	" On règle les touches d'activation manuelle de la correction orthographique
	noremap <F10> :setlocal spell spelllang=fr <CR>
	noremap <F11> :setlocal spell spelllang=en <CR>
	noremap <F12> :setlocal nospell <CR>
	noremap [29~ z=
endif

syntax keyword SpellBad ERROR

